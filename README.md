# TODO API for ecom.tech internship

TODO API - это сервис для работы с задачами(todos).

Сервис написан полностью на чистом GO(используется только стандартная либа)ю

Стек:
- Go 1.25.4
- Docker

## Makefile

Полезные команды:

Показывает все команды:
```bash
make help
```

Команда для запуска линтера и тестов(так же форматирует код):
```bash
make audit
```

## Поднятие сервиса

Склонируйте репозиторий в удобную вам дирикторию.
```bash
git clone https://github.com/vladgrskkh/todo .
```

Перед запуском следует настроить .env (для упрощения проверки
убрал .env из .gitignore, после проверки верну обратно)

Пример .env файла:
```env
API_TODO_PORT=8080
API_TODO_ENV=production
API_TODO_DB_PATH=todo.db
API_TODO_VERSION=v1.1.0-1-g5c1e3da-dirty
```

Для запуска можно воспользоваться несколькими командами:

Для запуска API:
```bash
make run/api
```

Для сборки бинарника:
```bash
make build/api
./bin/api
```

Через докер:
```bash
make build/docker/api
make run/docker/api
```

После поднятия сервис будет доступен по адресу http://localhost:8080

## Структура проекта

Старался следовать DDD и Clean arch.

Бизнес логика содержить в domain слое.

Handler слой отвечает за принятие запроса, вызов метода сервиса и отправки ответа.

Service слой организует data flow(в данном случае вызывает метод из repository).

Repository слой содержит api для взаимодействия с бд.

```text
├── cmd
│   └── api
├── config
│   └── config.go
├── Dockerfile
├── go.mod
├── internal
│   ├── apierrors
│   ├── domain
│   ├── handlers
│   ├── integrationtest
│   ├── paramutil
│   ├── repository
│   ├── server
│   └── service
├── Makefile
├── pkg
│   ├── envload
│   ├── inmemorydb
│   ├── jsonhttp
│   └── validator

```

## API

Эндпоинты:

Todos:
- `GET /todos/{id}` - получить задачу по id
- `GET /todos` - получить список всех задач
- `POST /todos` - создать новую задачу
- `PUT /todos/{id}` - обновить задачу по id
- `DELETE /todos/{id}` - удалить задачу по id

System:
- `GET /healthcheck` - проверка статуса сервиса
- `GET /metrics` - получить метрики(стандартные go метрики + метрики подсчета requests + бизнес метрики)

## CI

При пуше в main, development и feat/* ветки прогоняется CI пайплайн(линтер+тесты). В данном случае использую GitHub Actions.

## Что реализовано дополнительно

Так как можно использовать только std, были реализованы пакеты
для решения поставленных задач.

- Реализовал persistance inmemorydb. Все api находиться в директории pkg/inmemorydb.
Persistance реализуется при помощи записи в файл(при каждом put и del записывается команда в буфер, 
при повторном запуске все данные загружается в память).
- Реализовал пакет validation(небольшое api для удобства валидации бизнес правил).
- Реализовал пакет envload, помогает загрузить переменные окружения из env файла.
- Пакет jsonhttp помогает обрабатывать запросы и ответы в формате json.
- Все пакеты покрыты тестами и задокументированы

Так же дополнительно(в тз не было) реализованы:
- healthcheck endpoint
- metrics endpoint(expvar)
- logging middleware(в качестве логгера использую slog,
несмотря на то, что он из std, его вполне хватает для любых задач)

## Допушения

В тз указано: Убедитесь, что обрабатываются основные кейсы: успешное создание, ошибка валидации, дублирование идентификатора.
Отсюда я сделал вывод, что при создании задачи нужно указывать ее id(в моем случае id - int).

Так же я посчитал логичным, в случае если задача завершена(done), то как либо менять ее уже нельзя.

Для обновления задачи указан метод PUT, поэтому задача обновляется целиком.

Не успел реализовать update в пакете inmemorydb. Проблема, которую я хотел решить - lost updates.

Для этого нужно было импементировать механизм версионирования.
В теории это можно сделать и на уровне api, но в любом случае времени на это не остается(
    
А вообще для данной задачи лучше сделать привязку задачи к пользователю, тогда проблема lost updates решиться сама по себе.